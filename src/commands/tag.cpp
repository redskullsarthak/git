// implement tag cmd 
#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <algorithm>
#include "tag.hpp"
#include "show-ref.hpp"
#include "../utils/refWorker.hpp"
#include "../utils/fileProd.hpp"
#include "../utils/objectClasses.hpp"
#include "init.hpp"
using namespace std;

// implement ref create and tag create 
static void ref_create(gitDirectory *gd, const string &ref_name, const string &sha) {
    string path = gd->netpath + "/.mygit/refs/" + ref_name;
    std::filesystem::create_directories(std::filesystem::path(path).parent_path());
    ofstream out(path, ios::binary);
    if (!out.is_open()) { cout << "Error: could not write ref file: " << path << endl; return; }
    out << sha << "\n";
}

static void tag_create(gitDirectory *gd, const string &name, const string &ref, bool create_tag_object) {
    string net = gd->netpath;
    string want = create_tag_object ? string("commit") : string(""); // lightweight accepts any
    string fmt = want;
    string mutableRef = ref;
    string sha = fileFunctions::objectFind(net, mutableRef, fmt, true, gd);
    if (sha.empty()) { cout << "Error: could not resolve " << ref << endl; return; }

    if (create_tag_object) {
        // minimal annotated tag
        std::time_t now = std::time(nullptr);
        string raw;
        raw += "object " + sha + "\n";
        raw += "type commit\n";
        raw += "tag " + name + "\n";
        raw += "tagger Skirk <skirk@example.com> " + to_string(now) + " +0000\n";
        raw += "\nA tag generated by skirk\n";
        vector<unsigned char> content(raw.begin(), raw.end());
        auto tagObj = make_unique<Tag>(content);
        string tagSha = fileFunctions::writeObject(move(tagObj), gd->netpath);
        ref_create(gd, "tags/" + name, tagSha);
    } else {
        // lightweight
        ref_create(gd, "tags/" + name, sha);// simple refs just create them 
    }
}

void tag_cmd(vector<string> &args, gitDirectory *gd) {
    // args: ["skirk","tag", [-a], [name], [object]]
    bool annotated = false;
    vector<string> f;
    for (auto &a : args) { if (a=="-a") annotated=true; else f.push_back(a); }

    if (f.size() >= 3) {
        string name = f[2];
        string obj  = (f.size() >= 4 ? f[3] : string("HEAD"));
        tag_create(gd, name, obj, annotated);
        return;
    }

    // list tags
    string base = gd->netpath + "/.mygit/refs/tags";
    auto refs = refRelated::ref_list(base, gd);
    refRelated::show_ref(gd, refs, /*with_hash=*/false, "refs/tags");
}